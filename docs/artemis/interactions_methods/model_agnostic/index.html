<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>artemis.interactions_methods.model_agnostic API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>artemis.interactions_methods.model_agnostic</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .partial_dependence_based import FriedmanHStatisticMethod, GreenwellMethod
from .performance_based import SejongOhMethod

__all__ = [&#34;FriedmanHStatisticMethod&#34;, &#34;GreenwellMethod&#34;, &#34;SejongOhMethod&#34;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="artemis.interactions_methods.model_agnostic.partial_dependence_based" href="partial_dependence_based/index.html">artemis.interactions_methods.model_agnostic.partial_dependence_based</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="artemis.interactions_methods.model_agnostic.performance_based" href="performance_based/index.html">artemis.interactions_methods.model_agnostic.performance_based</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod"><code class="flex name class">
<span>class <span class="ident">FriedmanHStatisticMethod</span></span>
<span>(</span><span>random_state: Optional[int] = None, normalized: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Friedman's H-statistic Method for Feature Interaction Extraction. </p>
<p>Uses partial dependence values to calculate feature interaction strengths and feature importance. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str </code></dt>
<dd>Method name, used also for naming column with results in <code>ovo</code> pd.DataFrame.</dd>
<dt><strong><code>visualizer</code></strong> :&ensp;<code>Visualizer</code></dt>
<dd>Object providing visualization. Automatically created on the basis of a method and used to create visualizations.</dd>
<dt><strong><code>ovo</code></strong> :&ensp;<code>pd.DataFrame </code></dt>
<dd>One versus one (pair) feature interaction values.</dd>
<dt><strong><code>feature_importance</code></strong> :&ensp;<code>pd.DataFrame </code></dt>
<dd>Feature importance values.</dd>
<dt><strong><code>ova</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>One vs all feature interaction values.</dd>
<dt><strong><code>normalized</code></strong> :&ensp;<code>bool </code></dt>
<dd>Flag determining whether interaction values are normalized.
Unnrormalized version is proposed in <a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2021.2007935">https://www.tandfonline.com/doi/full/10.1080/10618600.2021.2007935</a></dd>
<dt><strong><code>model</code></strong> :&ensp;<code>object</code></dt>
<dd>Explained model.</dd>
<dt><strong><code>X_sampled</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Sampled data used for calculation.</dd>
<dt><strong><code>features_included</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of features for which interactions are calculated.</dd>
<dt><strong><code>pairs</code></strong> :&ensp;<code>List[List[str]]</code></dt>
<dd>List of pairs of features for which interactions are calculated.</dd>
<dt><strong><code>pd_calculator</code></strong> :&ensp;<code>PartialDependenceCalculator</code></dt>
<dd>Object used to calculate and store partial dependence values.</dd>
<dt><strong><code>batchsize</code></strong> :&ensp;<code>int</code></dt>
<dd>Batch size used for calculation.</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.jstor.org/stable/pdf/30245114.pdf">https://www.jstor.org/stable/pdf/30245114.pdf</a></li>
<li><a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2021.2007935">https://www.tandfonline.com/doi/full/10.1080/10618600.2021.2007935</a></li>
</ul>
<p>Constructor for FriedmanHStatisticMethod</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>random_state</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Random state for reproducibility. Defaults to None.</dd>
<dt><strong><code>normalized</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Flag determining whether to normalize the interaction values. Normalized version is original H-statistic,
unnrormalized version is square root of nominator of H statistic. Defaults to True which translates to original H-statistic.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FriedmanHStatisticMethod(PartialDependenceBasedMethod):
    &#34;&#34;&#34;
    Friedman&#39;s H-statistic Method for Feature Interaction Extraction. 
    
    Uses partial dependence values to calculate feature interaction strengths and feature importance. 

    Attributes
    ----------
    method : str 
        Method name, used also for naming column with results in `ovo` pd.DataFrame.
    visualizer : Visualizer
        Object providing visualization. Automatically created on the basis of a method and used to create visualizations.
    ovo : pd.DataFrame 
        One versus one (pair) feature interaction values. 
    feature_importance : pd.DataFrame 
        Feature importance values.
    ova : pd.DataFrame
        One vs all feature interaction values.
    normalized : bool 
        Flag determining whether interaction values are normalized.
        Unnrormalized version is proposed in https://www.tandfonline.com/doi/full/10.1080/10618600.2021.2007935
    model : object
        Explained model.
    X_sampled: pd.DataFrame
        Sampled data used for calculation.
    features_included: List[str]
        List of features for which interactions are calculated.
    pairs : List[List[str]]
        List of pairs of features for which interactions are calculated.
    pd_calculator : PartialDependenceCalculator
        Object used to calculate and store partial dependence values.
    batchsize : int
        Batch size used for calculation.

    References
    ----------
    - https://www.jstor.org/stable/pdf/30245114.pdf
    - https://www.tandfonline.com/doi/full/10.1080/10618600.2021.2007935
    &#34;&#34;&#34;
    def __init__(self, random_state: Optional[int] = None, normalized: bool = True):
        &#34;&#34;&#34;Constructor for FriedmanHStatisticMethod

        Parameters
        ----------
        random_state : int, optional
            Random state for reproducibility. Defaults to None.
        normalized : bool, optional 
            Flag determining whether to normalize the interaction values. Normalized version is original H-statistic, 
            unnrormalized version is square root of nominator of H statistic. Defaults to True which translates to original H-statistic.
        &#34;&#34;&#34;
        super().__init__(InteractionMethod.H_STATISTIC, random_state=random_state)
        self.ova = None
        self.normalized = normalized

    def fit(self,
            model,
            X: pd.DataFrame,
            n: Optional[int] = None,
            predict_function: Optional[Callable] = None,
            features: Optional[List[str]] = None,
            show_progress: bool = False,
            batchsize: int = 2000,
            pd_calculator: Optional[PartialDependenceCalculator] = None,
            calculate_ova: bool = True):
        &#34;&#34;&#34;Calculates H-statistic Feature Interactions Strength and Feature Importance for the given model. 
        Despite pair interactions, this method can also calculate one vs all interactions.

        Parameters
        ----------
        model : object
            Model to be explained, should have predict_proba or predict method, or predict_function should be provided. 
        X : pd.DataFrame
            Data used to calculate interactions. If n is not None, n rows from X will be sampled. 
        n : int, optional
            Number of samples to be used for calculation of interactions. If None, all rows from X will be used. Default is None.
        predict_function : Callable, optional
            Function used to predict model output. It should take model and dataset and outputs predictions. 
            If None, `predict_proba` method will be used if it exists, otherwise `predict` method. Default is None.
        features : List[str], optional
            List of features for which interactions will be calculated. If None, all features from X will be used. Default is None.
        show_progress : bool
            If True, progress bar will be shown. Default is False.
        batchsize : int
            Batch size for calculating partial dependence. Prediction requests are collected until the batchsize is exceeded, 
            then the model is queried for predictions jointly for many observations. It speeds up the operation of the method.
            Default is 2000.
        pd_calculator : PartialDependenceCalculator, optional
            PartialDependenceCalculator object containing partial dependence values for a given model and dataset. 
            Providing this object speeds up the calculation as partial dependence values do not need to be recalculated.
            If None, it will be created from scratch. Default is None.
        calculate_ova : bool
            If True, one vs all interactions will be calculated. Default is True.
        &#34;&#34;&#34;
        super().fit(model, X, n, predict_function, features, show_progress, batchsize, pd_calculator)
        if calculate_ova:
            self.ova = self._calculate_ova_interactions_from_pd(show_progress)

    def plot(self,
             vis_type: str = VisualizationType.HEATMAP,
             title: str = &#34;default&#34;,
             figsize: Tuple[float, float] = (8, 6),
             **kwargs):
        &#34;&#34;&#34;
        Plot results of explanations.

        There are five types of plots available:
        - heatmap - heatmap of feature interactions values with feature importance values on the diagonal (default)
        - bar_chart - bar chart of top feature interactions values
        - graph - graph of feature interactions values
        - bar_chart_ova - bar chart of top one vs all interactions values
        - summary - combination of other plots 
        
        Parameters
        ----------
        vis_type : str 
            Type of visualization, one of [&#39;heatmap&#39;, &#39;bar_chart&#39;, &#39;graph&#39;, &#39;bar_chart_ova&#39;, &#39;summary&#39;]. Default is &#39;heatmap&#39;.
        title : str 
            Title of plot, default is &#39;default&#39; which means that title will be automatically generated for selected visualization type.
        figsize : (float, float) 
            Size of plot. Default is (8, 6).
        **kwargs : Other Parameters
            Additional parameters for plot. Passed to suitable matplotlib or seaborn functions. 
            For &#39;summary&#39; visualization parameters for respective plots should be in dict with keys corresponding to visualization name. 
            See key parameters below. 

        Other Parameters
        ------------------------
        interaction_color_map : matplotlib colormap name or object, or list of colors
            Used for &#39;heatmap&#39; visualization. The mapping from interaction values to color space. Default is &#39;Purples&#39; or &#39;Purpler_r&#39;,
            depending on whether a greater value means a greater interaction strength or vice versa.
        importance_color_map :  matplotlib colormap name or object, or list of colors
            Used for &#39;heatmap&#39; visualization. The mapping from importance values to color space. Default is &#39;Greens&#39; or &#39;Greens_r&#39;,
            depending on whether a greater value means a greater interaction strength or vice versa.
        annot_fmt : str
            Used for &#39;heatmap&#39; visualization. String formatting code to use when adding annotations with values. Default is &#39;.3f&#39;.
        linewidths : float
            Used for &#39;heatmap&#39; visualization. Width of the lines that will divide each cell in matrix. Default is 0.5.
        linecolor : str
            Used for &#39;heatmap&#39; visualization. Color of the lines that will divide each cell in matrix. Default is &#39;white&#39;.
        cbar_shrink : float
            Used for &#39;heatmap&#39; visualization. Fraction by which to multiply the size of the colorbar. Default is 1. 
    
        top_k : int 
            Used for &#39;bar_chart&#39; and &#39;bar_chart_ova&#39; visualizations. Maximum number of pairs that will be presented in plot. Default is 10.
        color : str 
            Used for &#39;bar_chart&#39; and &#39;bar_chart_ova&#39; visualizations. Color of bars. Default is &#39;mediumpurple&#39;.

        n_highest_with_labels : int
            Used for &#39;graph&#39; visualization. Top most important interactions to show as labels on edges.  Default is 5.
        edge_color: str
            Used for &#39;graph&#39; visualization. Color of the edges. Default is &#39;rebeccapurple.
        node_color: str
            Used for &#39;graph&#39; visualization. Color of nodes. Default is &#39;green&#39;.
        node_size: int
            Used for &#39;graph&#39; visualization. Size of the nodes (networkX scale).  Default is &#39;1800&#39;.
        font_color: str
            Used for &#39;graph&#39; visualization. Font color. Default is &#39;#3B1F2B&#39;.
        font_weight: str
            Used for &#39;graph&#39; visualization. Font weight. Default is &#39;bold&#39;.
        font_size: int
            Used for &#39;graph&#39; visualization. Font size (networkX scale). Default is 10.
        threshold_relevant_interaction : float
            Used for &#39;graph&#39; visualization. Minimum (or maximum, depends on method) value of interaction to display
            corresponding edge on visualization. Default depends on the interaction method.
        &#34;&#34;&#34;
        if self.ova is None:
            raise MethodNotFittedException(self.method)

        self.visualizer.plot(self.ovo,
                             vis_type,
                             self.ova,
                             feature_importance=self.feature_importance,
                             title=title,
                             figsize=figsize,
                             interactions_ascending_order=self._interactions_ascending_order,
                             importance_ascending_order=self._feature_importance_obj.importance_ascending_order,
                             **kwargs)

    def plot_profile(
            self,
            feature1: str,
            feature2: Optional[str] = None,
            kind: str = &#34;colormesh&#34;,
            cmap: str = &#34;RdYlBu_r&#34;,
            figsize: Tuple[float, float] = (6, 4),
    ):
        super().plot_profile(feature1, feature2, kind, cmap, figsize)

    def plot_zenplot(
            self,
            zenpath_length: int = 7,
            kind: str = &#34;colormesh&#34;,
            cmap: str = &#34;RdYlBu_r&#34;,
            figsize: Tuple[float, float] = (14, 12),
    ):
        super().plot_zenplot(zenpath_length, kind, cmap, figsize)

    def _calculate_ova_interactions_from_pd(self, show_progress: bool) -&gt; pd.DataFrame:
        self.pd_calculator.calculate_pd_minus_single(self.features_included, show_progress=show_progress)
        preds = self.predict_function(self.model, self.X_sampled)
        value_minus_single = []
        for feature in self.features_included:
            pd_f = self.pd_calculator.get_pd_single(feature, feature_values=self.X_sampled[feature].values)
            pd_f_minus = self.pd_calculator.get_pd_minus_single(feature)
            value_minus_single.append([feature, _calculate_hstat_value(pd_f, pd_f_minus, preds, self.normalized)])
        return pd.DataFrame(value_minus_single, columns=[&#34;Feature&#34;, InteractionMethod.H_STATISTIC
                                                         ]).sort_values(by=InteractionMethod.H_STATISTIC,
                                                                        ascending=self._interactions_ascending_order,
                                                                        ignore_index=True).fillna(0)

    def _calculate_ovo_interactions_from_pd(self, show_progress: bool):
        self.pd_calculator.calculate_pd_pairs(self.pairs, show_progress=show_progress, all_combinations=False)
        self.pd_calculator.calculate_pd_single(self.features_included, show_progress=False)
        value_pairs = []
        for pair in self.pairs:
            pd_f1 = self.pd_calculator.get_pd_single(pair[0], feature_values=self.X_sampled[pair[0]].values)
            pd_f2 = self.pd_calculator.get_pd_single(pair[1], feature_values=self.X_sampled[pair[1]].values)
            pair_feature_values = list(zip(self.X_sampled[pair[0]].values, self.X_sampled[pair[1]].values))
            pd_pair = self.pd_calculator.get_pd_pairs(pair[0], pair[1], feature_values=pair_feature_values)
            value_pairs.append([pair[0], pair[1], _calculate_hstat_value(pd_f1, pd_f2, pd_pair, self.normalized)])
        return pd.DataFrame(value_pairs,
                            columns=[&#34;Feature 1&#34;, &#34;Feature 2&#34;,
                                     self.method]).sort_values(by=self.method,
                                                               ascending=self._interactions_ascending_order,
                                                               ignore_index=True).fillna(0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>artemis.interactions_methods.model_agnostic.partial_dependence_based._pdp.PartialDependenceBasedMethod</li>
<li>artemis.interactions_methods._method.FeatureInteractionMethod</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, model, X: pandas.core.frame.DataFrame, n: Optional[int] = None, predict_function: Optional[Callable] = None, features: Optional[List[str]] = None, show_progress: bool = False, batchsize: int = 2000, pd_calculator: Optional[artemis._utilities.pd_calculator.PartialDependenceCalculator] = None, calculate_ova: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates H-statistic Feature Interactions Strength and Feature Importance for the given model.
Despite pair interactions, this method can also calculate one vs all interactions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>object</code></dt>
<dd>Model to be explained, should have predict_proba or predict method, or predict_function should be provided.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Data used to calculate interactions. If n is not None, n rows from X will be sampled.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of samples to be used for calculation of interactions. If None, all rows from X will be used. Default is None.</dd>
<dt><strong><code>predict_function</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>Function used to predict model output. It should take model and dataset and outputs predictions.
If None, <code>predict_proba</code> method will be used if it exists, otherwise <code>predict</code> method. Default is None.</dd>
<dt><strong><code>features</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of features for which interactions will be calculated. If None, all features from X will be used. Default is None.</dd>
<dt><strong><code>show_progress</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, progress bar will be shown. Default is False.</dd>
<dt><strong><code>batchsize</code></strong> :&ensp;<code>int</code></dt>
<dd>Batch size for calculating partial dependence. Prediction requests are collected until the batchsize is exceeded,
then the model is queried for predictions jointly for many observations. It speeds up the operation of the method.
Default is 2000.</dd>
<dt><strong><code>pd_calculator</code></strong> :&ensp;<code>PartialDependenceCalculator</code>, optional</dt>
<dd>PartialDependenceCalculator object containing partial dependence values for a given model and dataset.
Providing this object speeds up the calculation as partial dependence values do not need to be recalculated.
If None, it will be created from scratch. Default is None.</dd>
<dt><strong><code>calculate_ova</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, one vs all interactions will be calculated. Default is True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self,
        model,
        X: pd.DataFrame,
        n: Optional[int] = None,
        predict_function: Optional[Callable] = None,
        features: Optional[List[str]] = None,
        show_progress: bool = False,
        batchsize: int = 2000,
        pd_calculator: Optional[PartialDependenceCalculator] = None,
        calculate_ova: bool = True):
    &#34;&#34;&#34;Calculates H-statistic Feature Interactions Strength and Feature Importance for the given model. 
    Despite pair interactions, this method can also calculate one vs all interactions.

    Parameters
    ----------
    model : object
        Model to be explained, should have predict_proba or predict method, or predict_function should be provided. 
    X : pd.DataFrame
        Data used to calculate interactions. If n is not None, n rows from X will be sampled. 
    n : int, optional
        Number of samples to be used for calculation of interactions. If None, all rows from X will be used. Default is None.
    predict_function : Callable, optional
        Function used to predict model output. It should take model and dataset and outputs predictions. 
        If None, `predict_proba` method will be used if it exists, otherwise `predict` method. Default is None.
    features : List[str], optional
        List of features for which interactions will be calculated. If None, all features from X will be used. Default is None.
    show_progress : bool
        If True, progress bar will be shown. Default is False.
    batchsize : int
        Batch size for calculating partial dependence. Prediction requests are collected until the batchsize is exceeded, 
        then the model is queried for predictions jointly for many observations. It speeds up the operation of the method.
        Default is 2000.
    pd_calculator : PartialDependenceCalculator, optional
        PartialDependenceCalculator object containing partial dependence values for a given model and dataset. 
        Providing this object speeds up the calculation as partial dependence values do not need to be recalculated.
        If None, it will be created from scratch. Default is None.
    calculate_ova : bool
        If True, one vs all interactions will be calculated. Default is True.
    &#34;&#34;&#34;
    super().fit(model, X, n, predict_function, features, show_progress, batchsize, pd_calculator)
    if calculate_ova:
        self.ova = self._calculate_ova_interactions_from_pd(show_progress)</code></pre>
</details>
</dd>
<dt id="artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, vis_type: str = 'heatmap', title: str = 'default', figsize: Tuple[float, float] = (8, 6), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot results of explanations.</p>
<p>There are five types of plots available:
- heatmap - heatmap of feature interactions values with feature importance values on the diagonal (default)
- bar_chart - bar chart of top feature interactions values
- graph - graph of feature interactions values
- bar_chart_ova - bar chart of top one vs all interactions values
- summary - combination of other plots </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vis_type</code></strong> :&ensp;<code>str </code></dt>
<dd>Type of visualization, one of ['heatmap', 'bar_chart', 'graph', 'bar_chart_ova', 'summary']. Default is 'heatmap'.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str </code></dt>
<dd>Title of plot, default is 'default' which means that title will be automatically generated for selected visualization type.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>(float, float) </code></dt>
<dd>Size of plot. Default is (8, 6).</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>Other Parameters</code></dt>
<dd>Additional parameters for plot. Passed to suitable matplotlib or seaborn functions.
For 'summary' visualization parameters for respective plots should be in dict with keys corresponding to visualization name.
See key parameters below.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>interaction_color_map</code></strong> :&ensp;<code>matplotlib colormap name</code> or <code>object,</code> or <code>list</code> of <code>colors</code></dt>
<dd>Used for 'heatmap' visualization. The mapping from interaction values to color space. Default is 'Purples' or 'Purpler_r',
depending on whether a greater value means a greater interaction strength or vice versa.</dd>
<dt><strong><code>importance_color_map</code></strong> :&ensp;<code> matplotlib colormap name</code> or <code>object,</code> or <code>list</code> of <code>colors</code></dt>
<dd>Used for 'heatmap' visualization. The mapping from importance values to color space. Default is 'Greens' or 'Greens_r',
depending on whether a greater value means a greater interaction strength or vice versa.</dd>
<dt><strong><code>annot_fmt</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'heatmap' visualization. String formatting code to use when adding annotations with values. Default is '.3f'.</dd>
<dt><strong><code>linewidths</code></strong> :&ensp;<code>float</code></dt>
<dd>Used for 'heatmap' visualization. Width of the lines that will divide each cell in matrix. Default is 0.5.</dd>
<dt><strong><code>linecolor</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'heatmap' visualization. Color of the lines that will divide each cell in matrix. Default is 'white'.</dd>
<dt><strong><code>cbar_shrink</code></strong> :&ensp;<code>float</code></dt>
<dd>Used for 'heatmap' visualization. Fraction by which to multiply the size of the colorbar. Default is 1.</dd>
<dt><strong><code>top_k</code></strong> :&ensp;<code>int </code></dt>
<dd>Used for 'bar_chart' and 'bar_chart_ova' visualizations. Maximum number of pairs that will be presented in plot. Default is 10.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str </code></dt>
<dd>Used for 'bar_chart' and 'bar_chart_ova' visualizations. Color of bars. Default is 'mediumpurple'.</dd>
<dt><strong><code>n_highest_with_labels</code></strong> :&ensp;<code>int</code></dt>
<dd>Used for 'graph' visualization. Top most important interactions to show as labels on edges.
Default is 5.</dd>
<dt><strong><code>edge_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Color of the edges. Default is 'rebeccapurple.</dd>
<dt><strong><code>node_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Color of nodes. Default is 'green'.</dd>
<dt><strong><code>node_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Used for 'graph' visualization. Size of the nodes (networkX scale).
Default is '1800'.</dd>
<dt><strong><code>font_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Font color. Default is '#3B1F2B'.</dd>
<dt><strong><code>font_weight</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Font weight. Default is 'bold'.</dd>
<dt><strong><code>font_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Used for 'graph' visualization. Font size (networkX scale). Default is 10.</dd>
<dt><strong><code>threshold_relevant_interaction</code></strong> :&ensp;<code>float</code></dt>
<dd>Used for 'graph' visualization. Minimum (or maximum, depends on method) value of interaction to display
corresponding edge on visualization. Default depends on the interaction method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         vis_type: str = VisualizationType.HEATMAP,
         title: str = &#34;default&#34;,
         figsize: Tuple[float, float] = (8, 6),
         **kwargs):
    &#34;&#34;&#34;
    Plot results of explanations.

    There are five types of plots available:
    - heatmap - heatmap of feature interactions values with feature importance values on the diagonal (default)
    - bar_chart - bar chart of top feature interactions values
    - graph - graph of feature interactions values
    - bar_chart_ova - bar chart of top one vs all interactions values
    - summary - combination of other plots 
    
    Parameters
    ----------
    vis_type : str 
        Type of visualization, one of [&#39;heatmap&#39;, &#39;bar_chart&#39;, &#39;graph&#39;, &#39;bar_chart_ova&#39;, &#39;summary&#39;]. Default is &#39;heatmap&#39;.
    title : str 
        Title of plot, default is &#39;default&#39; which means that title will be automatically generated for selected visualization type.
    figsize : (float, float) 
        Size of plot. Default is (8, 6).
    **kwargs : Other Parameters
        Additional parameters for plot. Passed to suitable matplotlib or seaborn functions. 
        For &#39;summary&#39; visualization parameters for respective plots should be in dict with keys corresponding to visualization name. 
        See key parameters below. 

    Other Parameters
    ------------------------
    interaction_color_map : matplotlib colormap name or object, or list of colors
        Used for &#39;heatmap&#39; visualization. The mapping from interaction values to color space. Default is &#39;Purples&#39; or &#39;Purpler_r&#39;,
        depending on whether a greater value means a greater interaction strength or vice versa.
    importance_color_map :  matplotlib colormap name or object, or list of colors
        Used for &#39;heatmap&#39; visualization. The mapping from importance values to color space. Default is &#39;Greens&#39; or &#39;Greens_r&#39;,
        depending on whether a greater value means a greater interaction strength or vice versa.
    annot_fmt : str
        Used for &#39;heatmap&#39; visualization. String formatting code to use when adding annotations with values. Default is &#39;.3f&#39;.
    linewidths : float
        Used for &#39;heatmap&#39; visualization. Width of the lines that will divide each cell in matrix. Default is 0.5.
    linecolor : str
        Used for &#39;heatmap&#39; visualization. Color of the lines that will divide each cell in matrix. Default is &#39;white&#39;.
    cbar_shrink : float
        Used for &#39;heatmap&#39; visualization. Fraction by which to multiply the size of the colorbar. Default is 1. 

    top_k : int 
        Used for &#39;bar_chart&#39; and &#39;bar_chart_ova&#39; visualizations. Maximum number of pairs that will be presented in plot. Default is 10.
    color : str 
        Used for &#39;bar_chart&#39; and &#39;bar_chart_ova&#39; visualizations. Color of bars. Default is &#39;mediumpurple&#39;.

    n_highest_with_labels : int
        Used for &#39;graph&#39; visualization. Top most important interactions to show as labels on edges.  Default is 5.
    edge_color: str
        Used for &#39;graph&#39; visualization. Color of the edges. Default is &#39;rebeccapurple.
    node_color: str
        Used for &#39;graph&#39; visualization. Color of nodes. Default is &#39;green&#39;.
    node_size: int
        Used for &#39;graph&#39; visualization. Size of the nodes (networkX scale).  Default is &#39;1800&#39;.
    font_color: str
        Used for &#39;graph&#39; visualization. Font color. Default is &#39;#3B1F2B&#39;.
    font_weight: str
        Used for &#39;graph&#39; visualization. Font weight. Default is &#39;bold&#39;.
    font_size: int
        Used for &#39;graph&#39; visualization. Font size (networkX scale). Default is 10.
    threshold_relevant_interaction : float
        Used for &#39;graph&#39; visualization. Minimum (or maximum, depends on method) value of interaction to display
        corresponding edge on visualization. Default depends on the interaction method.
    &#34;&#34;&#34;
    if self.ova is None:
        raise MethodNotFittedException(self.method)

    self.visualizer.plot(self.ovo,
                         vis_type,
                         self.ova,
                         feature_importance=self.feature_importance,
                         title=title,
                         figsize=figsize,
                         interactions_ascending_order=self._interactions_ascending_order,
                         importance_ascending_order=self._feature_importance_obj.importance_ascending_order,
                         **kwargs)</code></pre>
</details>
</dd>
<dt id="artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.plot_profile"><code class="name flex">
<span>def <span class="ident">plot_profile</span></span>(<span>self, feature1: str, feature2: Optional[str] = None, kind: str = 'colormesh', cmap: str = 'RdYlBu_r', figsize: Tuple[float, float] = (6, 4))</span>
</code></dt>
<dd>
<div class="desc"><p>Plots partial dependence profile for a given feature/pair of features.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature1</code></strong> :&ensp;<code>str </code></dt>
<dd>First feature.</dd>
<dt><strong><code>feature2</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Second feature. If None, profile for a single feature will be plotted. Default is None.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>str </code></dt>
<dd>Kind of plot, used only for pair of features. Can be 'colormesh' or 'contour'. Default is 'colormesh'.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str </code></dt>
<dd>Colormap. Default is 'RdYlBu_r'.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>(float, float) </code></dt>
<dd>Size of plot. Default is (8, 6).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_profile(
        self,
        feature1: str,
        feature2: Optional[str] = None,
        kind: str = &#34;colormesh&#34;,
        cmap: str = &#34;RdYlBu_r&#34;,
        figsize: Tuple[float, float] = (6, 4),
):
    super().plot_profile(feature1, feature2, kind, cmap, figsize)</code></pre>
</details>
</dd>
<dt id="artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.plot_zenplot"><code class="name flex">
<span>def <span class="ident">plot_zenplot</span></span>(<span>self, zenpath_length: int = 7, kind: str = 'colormesh', cmap: str = 'RdYlBu_r', figsize: Tuple[float, float] = (14, 12))</span>
</code></dt>
<dd>
<div class="desc"><p>Plots zenplot, a grid of charts where each panel contains a PD function visualization for a different pair of features</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>zenpath_length</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of zenpath. Default is 7.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>str </code></dt>
<dd>Kind of plot. Can be 'colormesh' or 'contour'. Default is 'colormesh'.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str </code></dt>
<dd>Colormap. Default is 'RdYlBu_r'.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>(float, float) </code></dt>
<dd>Size of plot. Default is (8, 6).</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.jstatsoft.org/article/view/v095i04">https://www.jstatsoft.org/article/view/v095i04</a></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_zenplot(
        self,
        zenpath_length: int = 7,
        kind: str = &#34;colormesh&#34;,
        cmap: str = &#34;RdYlBu_r&#34;,
        figsize: Tuple[float, float] = (14, 12),
):
    super().plot_zenplot(zenpath_length, kind, cmap, figsize)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="artemis.interactions_methods.model_agnostic.GreenwellMethod"><code class="flex name class">
<span>class <span class="ident">GreenwellMethod</span></span>
<span>(</span><span>random_state: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Greenwell Method for Feature Interaction Extraction. </p>
<p>Uses partial dependence values to calculate feature interaction strengths and feature importance. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str </code></dt>
<dd>Method name, used also for naming column with results in <code>ovo</code> pd.DataFrame.</dd>
<dt><strong><code>visualizer</code></strong> :&ensp;<code>Visualizer</code></dt>
<dd>Object providing visualization. Automatically created on the basis of a method and used to create visualizations.</dd>
<dt><strong><code>ovo</code></strong> :&ensp;<code>pd.DataFrame </code></dt>
<dd>One versus one (pair) feature interaction values.</dd>
<dt><strong><code>feature_importance</code></strong> :&ensp;<code>pd.DataFrame </code></dt>
<dd>Feature importance values.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>object</code></dt>
<dd>Explained model.</dd>
<dt><strong><code>X_sampled</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Sampled data used for calculation.</dd>
<dt><strong><code>features_included</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of features for which interactions are calculated.</dd>
<dt><strong><code>pairs</code></strong> :&ensp;<code>List[List[str]]</code></dt>
<dd>List of pairs of features for which interactions are calculated.</dd>
<dt><strong><code>pd_calculator</code></strong> :&ensp;<code>PartialDependenceCalculator</code></dt>
<dd>Object used to calculate and store partial dependence values.</dd>
<dt><strong><code>batchsize</code></strong> :&ensp;<code>int</code></dt>
<dd>Batch size used for calculation.</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li><a href="https://arxiv.org/pdf/1805.04755.pdf">https://arxiv.org/pdf/1805.04755.pdf</a></li>
</ul>
<p>Constructor for GreenwellMethod</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>random_state</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Random state for reproducibility. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GreenwellMethod(PartialDependenceBasedMethod):
    &#34;&#34;&#34;
    Greenwell Method for Feature Interaction Extraction. 
    
    Uses partial dependence values to calculate feature interaction strengths and feature importance. 

    Attributes
    ----------
    method : str 
        Method name, used also for naming column with results in `ovo` pd.DataFrame.
    visualizer : Visualizer
        Object providing visualization. Automatically created on the basis of a method and used to create visualizations.
    ovo : pd.DataFrame 
        One versus one (pair) feature interaction values. 
    feature_importance : pd.DataFrame 
        Feature importance values.
    model : object
        Explained model.
    X_sampled: pd.DataFrame
        Sampled data used for calculation.
    features_included: List[str]
        List of features for which interactions are calculated.
    pairs : List[List[str]]
        List of pairs of features for which interactions are calculated.
    pd_calculator : PartialDependenceCalculator
        Object used to calculate and store partial dependence values.
    batchsize : int
        Batch size used for calculation.

    References
    ----------
    - https://arxiv.org/pdf/1805.04755.pdf
    &#34;&#34;&#34;
    def __init__(self, random_state: Optional[int] = None):
        &#34;&#34;&#34;Constructor for GreenwellMethod
        
        Parameters
        ----------
        random_state : int, optional 
            Random state for reproducibility. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(InteractionMethod.VARIABLE_INTERACTION, random_state=random_state)

    def fit(self,
            model,
            X: pd.DataFrame,
            n: Optional[int] = None,
            predict_function: Optional[Callable] = None,
            features: Optional[List[str]] = None,
            show_progress: bool = False,
            batchsize: int = 2000,
            pd_calculator: Optional[PartialDependenceCalculator] = None):
        super().fit(model, X, n, predict_function, features, show_progress, batchsize, pd_calculator)

    def plot(self,
             vis_type: str = VisualizationType.HEATMAP,
             title: str = &#34;default&#34;,
             figsize: Tuple[float, float] = (8, 6),
             **kwargs):
        super().plot(vis_type, title, figsize, **kwargs)

    def plot_profile(
            self,
            feature1: str,
            feature2: Optional[str] = None,
            kind: str = &#34;colormesh&#34;,
            cmap: str = &#34;RdYlBu_r&#34;,
            figsize: Tuple[float, float] = (6, 4),
    ):
        super().plot_profile(feature1, feature2, kind, cmap, figsize)

    def plot_zenplot(
            self,
            zenpath_length: int = 7,
            kind: str = &#34;colormesh&#34;,
            cmap: str = &#34;RdYlBu_r&#34;,
            figsize: Tuple[float, float] = (14, 12),
    ):
        super().plot_zenplot(zenpath_length, kind, cmap, figsize)

    def _calculate_ovo_interactions_from_pd(self, show_progress: bool = False):
        self.pd_calculator.calculate_pd_pairs(self.pairs, show_progress=show_progress)
        value_pairs = []
        num_features, _ = split_features_num_cat(self.X_sampled, self.features_included)
        for pair in self.pairs:
            pair = self.pd_calculator._get_pair_key((pair[0], pair[1]))
            pd_values = self.pd_calculator.get_pd_pairs(pair[0], pair[1])
            res_j = np.apply_along_axis(stdev, 0, np.apply_along_axis(_calc_conditional_imp, 1, pd_values,
                                                                      is_numerical=pair[1] in num_features))
            res_i = np.apply_along_axis(stdev, 0, np.apply_along_axis(_calc_conditional_imp, 0, pd_values,
                                                                      is_numerical=pair[0] in num_features))
            value_pairs.append([pair[0], pair[1], (res_j + res_i) / 2])
        return pd.DataFrame(value_pairs, columns=[&#34;Feature 1&#34;, &#34;Feature 2&#34;, self.method]).sort_values(
            by=self.method, ascending=self._interactions_ascending_order, ignore_index=True
        ).fillna(0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>artemis.interactions_methods.model_agnostic.partial_dependence_based._pdp.PartialDependenceBasedMethod</li>
<li>artemis.interactions_methods._method.FeatureInteractionMethod</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="artemis.interactions_methods.model_agnostic.GreenwellMethod.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, model, X: pandas.core.frame.DataFrame, n: Optional[int] = None, predict_function: Optional[Callable] = None, features: Optional[List[str]] = None, show_progress: bool = False, batchsize: int = 2000, pd_calculator: Optional[artemis._utilities.pd_calculator.PartialDependenceCalculator] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates Partial Dependence Based Feature Interactions Strength and Feature Importance for the given model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>object</code></dt>
<dd>Model to be explained, should have predict_proba or predict method, or predict_function should be provided.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Data used to calculate interactions. If n is not None, n rows from X will be sampled.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of samples to be used for calculation of interactions. If None, all rows from X will be used. Default is None.</dd>
<dt><strong><code>predict_function</code></strong> :&ensp;<code>Callable</code>, optional</dt>
<dd>Function used to predict model output. It should take model and dataset and outputs predictions.
If None, <code>predict_proba</code> method will be used if it exists, otherwise <code>predict</code> method. Default is None.</dd>
<dt><strong><code>features</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of features for which interactions will be calculated. If None, all features from X will be used. Default is None.</dd>
<dt><strong><code>show_progress</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, progress bar will be shown. Default is False.</dd>
<dt><strong><code>batchsize</code></strong> :&ensp;<code>int</code></dt>
<dd>Batch size for calculating partial dependence. Prediction requests are collected until the batchsize is exceeded,
then the model is queried for predictions jointly for many observations. It speeds up the operation of the method.
Default is 2000.</dd>
<dt><strong><code>pd_calculator</code></strong> :&ensp;<code>PartialDependenceCalculator</code>, optional</dt>
<dd>PartialDependenceCalculator object containing partial dependence values for a given model and dataset.
Providing this object speeds up the calculation as partial dependence values do not need to be recalculated.
If None, it will be created from scratch. Default is None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(self,
        model,
        X: pd.DataFrame,
        n: Optional[int] = None,
        predict_function: Optional[Callable] = None,
        features: Optional[List[str]] = None,
        show_progress: bool = False,
        batchsize: int = 2000,
        pd_calculator: Optional[PartialDependenceCalculator] = None):
    super().fit(model, X, n, predict_function, features, show_progress, batchsize, pd_calculator)</code></pre>
</details>
</dd>
<dt id="artemis.interactions_methods.model_agnostic.GreenwellMethod.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, vis_type: str = 'heatmap', title: str = 'default', figsize: Tuple[float, float] = (8, 6), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot results of explanations.</p>
<p>There are four types of plots available:
- heatmap - heatmap of feature interactions values with feature importance values on the diagonal (default)
- bar_chart - bar chart of top feature interactions values
- graph - graph of feature interactions values
- summary - combination of other plots </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vis_type</code></strong> :&ensp;<code>str </code></dt>
<dd>Type of visualization, one of ['heatmap', 'bar_chart', 'graph', 'summary']. Default is 'heatmap'.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str </code></dt>
<dd>Title of plot, default is 'default' which means that title will be automatically generated for selected visualization type.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>(float, float) </code></dt>
<dd>Size of plot. Default is (8, 6).</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>Other Parameters</code></dt>
<dd>Additional parameters for plot. Passed to suitable matplotlib or seaborn functions.
For 'summary' visualization parameters for respective plots should be in dict with keys corresponding to visualization name.
See key parameters below.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>interaction_color_map</code></strong> :&ensp;<code>matplotlib colormap name</code> or <code>object,</code> or <code>list</code> of <code>colors</code></dt>
<dd>Used for 'heatmap' visualization. The mapping from interaction values to color space. Default is 'Purples' or 'Purpler_r',
depending on whether a greater value means a greater interaction strength or vice versa.</dd>
<dt><strong><code>importance_color_map</code></strong> :&ensp;<code> matplotlib colormap name</code> or <code>object,</code> or <code>list</code> of <code>colors</code></dt>
<dd>Used for 'heatmap' visualization. The mapping from importance values to color space. Default is 'Greens' or 'Greens_r',
depending on whether a greater value means a greater interaction strength or vice versa.</dd>
<dt><strong><code>annot_fmt</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'heatmap' visualization. String formatting code to use when adding annotations with values. Default is '.3f'.</dd>
<dt><strong><code>linewidths</code></strong> :&ensp;<code>float</code></dt>
<dd>Used for 'heatmap' visualization. Width of the lines that will divide each cell in matrix. Default is 0.5.</dd>
<dt><strong><code>linecolor</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'heatmap' visualization. Color of the lines that will divide each cell in matrix. Default is 'white'.</dd>
<dt><strong><code>cbar_shrink</code></strong> :&ensp;<code>float</code></dt>
<dd>Used for 'heatmap' visualization. Fraction by which to multiply the size of the colorbar. Default is 1.</dd>
<dt><strong><code>top_k</code></strong> :&ensp;<code>int </code></dt>
<dd>Used for 'bar_chart' visualization. Maximum number of pairs that will be presented in plot. Default is 10.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str </code></dt>
<dd>Used for 'bar_chart' visualization. Color of bars. Default is 'mediumpurple'.</dd>
<dt><strong><code>n_highest_with_labels</code></strong> :&ensp;<code>int</code></dt>
<dd>Used for 'graph' visualization. Top most important interactions to show as labels on edges.
Default is 5.</dd>
<dt><strong><code>edge_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Color of the edges. Default is 'rebeccapurple.</dd>
<dt><strong><code>node_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Color of nodes. Default is 'green'.</dd>
<dt><strong><code>node_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Used for 'graph' visualization. Size of the nodes (networkX scale).
Default is '1800'.</dd>
<dt><strong><code>font_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Font color. Default is '#3B1F2B'.</dd>
<dt><strong><code>font_weight</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Font weight. Default is 'bold'.</dd>
<dt><strong><code>font_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Used for 'graph' visualization. Font size (networkX scale). Default is 10.</dd>
<dt><strong><code>threshold_relevant_interaction</code></strong> :&ensp;<code>float</code></dt>
<dd>Used for 'graph' visualization. Minimum (or maximum, depends on method) value of interaction to display
corresponding edge on visualization. Default depends on the interaction method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         vis_type: str = VisualizationType.HEATMAP,
         title: str = &#34;default&#34;,
         figsize: Tuple[float, float] = (8, 6),
         **kwargs):
    super().plot(vis_type, title, figsize, **kwargs)</code></pre>
</details>
</dd>
<dt id="artemis.interactions_methods.model_agnostic.GreenwellMethod.plot_profile"><code class="name flex">
<span>def <span class="ident">plot_profile</span></span>(<span>self, feature1: str, feature2: Optional[str] = None, kind: str = 'colormesh', cmap: str = 'RdYlBu_r', figsize: Tuple[float, float] = (6, 4))</span>
</code></dt>
<dd>
<div class="desc"><p>Plots partial dependence profile for a given feature/pair of features.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>feature1</code></strong> :&ensp;<code>str </code></dt>
<dd>First feature.</dd>
<dt><strong><code>feature2</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Second feature. If None, profile for a single feature will be plotted. Default is None.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>str </code></dt>
<dd>Kind of plot, used only for pair of features. Can be 'colormesh' or 'contour'. Default is 'colormesh'.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str </code></dt>
<dd>Colormap. Default is 'RdYlBu_r'.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>(float, float) </code></dt>
<dd>Size of plot. Default is (8, 6).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_profile(
        self,
        feature1: str,
        feature2: Optional[str] = None,
        kind: str = &#34;colormesh&#34;,
        cmap: str = &#34;RdYlBu_r&#34;,
        figsize: Tuple[float, float] = (6, 4),
):
    super().plot_profile(feature1, feature2, kind, cmap, figsize)</code></pre>
</details>
</dd>
<dt id="artemis.interactions_methods.model_agnostic.GreenwellMethod.plot_zenplot"><code class="name flex">
<span>def <span class="ident">plot_zenplot</span></span>(<span>self, zenpath_length: int = 7, kind: str = 'colormesh', cmap: str = 'RdYlBu_r', figsize: Tuple[float, float] = (14, 12))</span>
</code></dt>
<dd>
<div class="desc"><p>Plots zenplot, a grid of charts where each panel contains a PD function visualization for a different pair of features</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>zenpath_length</code></strong> :&ensp;<code>int</code></dt>
<dd>Length of zenpath. Default is 7.</dd>
<dt><strong><code>kind</code></strong> :&ensp;<code>str </code></dt>
<dd>Kind of plot. Can be 'colormesh' or 'contour'. Default is 'colormesh'.</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>str </code></dt>
<dd>Colormap. Default is 'RdYlBu_r'.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>(float, float) </code></dt>
<dd>Size of plot. Default is (8, 6).</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.jstatsoft.org/article/view/v095i04">https://www.jstatsoft.org/article/view/v095i04</a></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_zenplot(
        self,
        zenpath_length: int = 7,
        kind: str = &#34;colormesh&#34;,
        cmap: str = &#34;RdYlBu_r&#34;,
        figsize: Tuple[float, float] = (14, 12),
):
    super().plot_zenplot(zenpath_length, kind, cmap, figsize)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="artemis.interactions_methods.model_agnostic.SejongOhMethod"><code class="flex name class">
<span>class <span class="ident">SejongOhMethod</span></span>
<span>(</span><span>metric: artemis._utilities.performance_metrics.Metric = &lt;artemis._utilities.performance_metrics.RMSE object&gt;, random_state: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sejong Oh's Performance Based Method for Feature Interaction Extraction. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str </code></dt>
<dd>Method name, used also for naming column with results in <code>ovo</code> pd.DataFrame.</dd>
<dt><strong><code>visualizer</code></strong> :&ensp;<code>Visualizer</code></dt>
<dd>Object providing visualization. Automatically created on the basis of a method and used to create visualizations.</dd>
<dt><strong><code>ovo</code></strong> :&ensp;<code>pd.DataFrame </code></dt>
<dd>One versus one (pair) feature interaction values.</dd>
<dt><strong><code>feature_importance</code></strong> :&ensp;<code>pd.DataFrame </code></dt>
<dd>Feature importance values.</dd>
<dt><strong><code>metric</code></strong> :&ensp;<code>Metric</code></dt>
<dd>Metric used for calculating performance.</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>object</code></dt>
<dd>Explained model.</dd>
<dt><strong><code>X_sampled</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Sampled data used for calculation.</dd>
<dt><strong><code>y_sampled</code></strong> :&ensp;<code>np.array</code> or <code>pd.Series</code></dt>
<dd>Sampled target values used for calculation.</dd>
<dt><strong><code>features_included</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>List of features for which interactions are calculated.</dd>
<dt><strong><code>pairs</code></strong> :&ensp;<code>List[List[str]]</code></dt>
<dd>List of pairs of features for which interactions are calculated.</dd>
<dt><strong><code>random_state</code></strong> :&ensp;<code>int</code></dt>
<dd>Random state used for reproducibility.</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.mdpi.com/2076-3417/9/23/5191">https://www.mdpi.com/2076-3417/9/23/5191</a></li>
</ul>
<p>Constructor for SejongOhMethod</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>metric</code></strong> :&ensp;<code>Metric</code></dt>
<dd>Metric used to calculate model performance. Defaults to RMSE().</dd>
<dt><strong><code>random_state</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Random state for reproducibility. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SejongOhMethod(FeatureInteractionMethod):
    &#34;&#34;&#34;
    Sejong Oh&#39;s Performance Based Method for Feature Interaction Extraction. 
    
    Attributes
    ----------
    method : str 
        Method name, used also for naming column with results in `ovo` pd.DataFrame.
    visualizer : Visualizer
        Object providing visualization. Automatically created on the basis of a method and used to create visualizations.
    ovo : pd.DataFrame 
        One versus one (pair) feature interaction values. 
    feature_importance : pd.DataFrame 
        Feature importance values.
    metric : Metric
        Metric used for calculating performance.
    model : object
        Explained model.
    X_sampled: pd.DataFrame
        Sampled data used for calculation.
    y_sampled: np.array or pd.Series
        Sampled target values used for calculation.
    features_included: List[str]
        List of features for which interactions are calculated.
    pairs : List[List[str]]
        List of pairs of features for which interactions are calculated.
    random_state : int
        Random state used for reproducibility.

    References
    ----------
    - https://www.mdpi.com/2076-3417/9/23/5191
    &#34;&#34;&#34;

    def __init__(self, metric: Metric = RMSE(), random_state: Optional[int] = None):
        &#34;&#34;&#34;Constructor for SejongOhMethod
        
        Parameters
        ----------
        metric : Metric
            Metric used to calculate model performance. Defaults to RMSE().
        random_state : int, optional 
            Random state for reproducibility. Defaults to None.
        &#34;&#34;&#34;
        super().__init__(InteractionMethod.PERFORMANCE_BASED, random_state)
        self.metric = metric
        self.y_sampled = None

    @property
    def _interactions_ascending_order(self):
        return False

    def plot(self, vis_type: str = VisualizationType.HEATMAP, title: str = &#34;default&#34;,
             figsize: Tuple[float, float] = (8, 6), **kwargs):
        super().plot(vis_type, title, figsize, **kwargs)

    def fit(
            self,
            model,
            X: pd.DataFrame,
            y_true: Union[np.array, pd.Series],  
            n: int = None,
            n_repeat: int = 10,
            features: List[str] = None,
            show_progress: bool = False,
    ):  
        &#34;&#34;&#34;Calculates Performance Based Feature Interactions Strength and Permutation Based Feature Importance for the given model.

        Parameters
        ----------
        model : object
            Model to be explained, should have predict method.
        X : pd.DataFrame
            Data used to calculate interactions. If n is not None, n rows from X will be sampled. 
        y_true : np.array or pd.Series
            Target values for X data. 
        n : int, optional
            Number of samples to be used for calculation of interactions. If None, all rows from X will be used. Default is None.
        n_repeat : int, optional
            Number of permutations. Default is 10.
        features : List[str], optional
            List of features for which interactions will be calculated. If None, all features from X will be used. Default is None.
        show_progress : bool
            If True, progress bar will be shown. Default is False.
        &#34;&#34;&#34;
        self.X_sampled, self.y_sampled = sample_both_if_not_none(self._random_generator, X, y_true, n)
        self.features_included = all_if_none(X.columns, features)
        self.pairs = list(combinations(self.features_included, 2))
        self.ovo = _perf_based_ovo(self, model, self.X_sampled, self.y_sampled, n_repeat, show_progress)

        # calculate feature importance
        self._feature_importance_obj = PermutationImportance(self.metric)
        self.feature_importance = self._feature_importance_obj.importance(model, X=self.X_sampled,
                                                                            y_true=self.y_sampled,
                                                                            n_repeat=n_repeat,
                                                                            features=self.features_included,
                                                                            show_progress=show_progress)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>artemis.interactions_methods._method.FeatureInteractionMethod</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="artemis.interactions_methods.model_agnostic.SejongOhMethod.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, model, X: pandas.core.frame.DataFrame, y_true: Union[<built-in function array>, pandas.core.series.Series], n: int = None, n_repeat: int = 10, features: List[str] = None, show_progress: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates Performance Based Feature Interactions Strength and Permutation Based Feature Importance for the given model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>object</code></dt>
<dd>Model to be explained, should have predict method.</dd>
<dt><strong><code>X</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Data used to calculate interactions. If n is not None, n rows from X will be sampled.</dd>
<dt><strong><code>y_true</code></strong> :&ensp;<code>np.array</code> or <code>pd.Series</code></dt>
<dd>Target values for X data.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of samples to be used for calculation of interactions. If None, all rows from X will be used. Default is None.</dd>
<dt><strong><code>n_repeat</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of permutations. Default is 10.</dd>
<dt><strong><code>features</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List of features for which interactions will be calculated. If None, all features from X will be used. Default is None.</dd>
<dt><strong><code>show_progress</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, progress bar will be shown. Default is False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(
        self,
        model,
        X: pd.DataFrame,
        y_true: Union[np.array, pd.Series],  
        n: int = None,
        n_repeat: int = 10,
        features: List[str] = None,
        show_progress: bool = False,
):  
    &#34;&#34;&#34;Calculates Performance Based Feature Interactions Strength and Permutation Based Feature Importance for the given model.

    Parameters
    ----------
    model : object
        Model to be explained, should have predict method.
    X : pd.DataFrame
        Data used to calculate interactions. If n is not None, n rows from X will be sampled. 
    y_true : np.array or pd.Series
        Target values for X data. 
    n : int, optional
        Number of samples to be used for calculation of interactions. If None, all rows from X will be used. Default is None.
    n_repeat : int, optional
        Number of permutations. Default is 10.
    features : List[str], optional
        List of features for which interactions will be calculated. If None, all features from X will be used. Default is None.
    show_progress : bool
        If True, progress bar will be shown. Default is False.
    &#34;&#34;&#34;
    self.X_sampled, self.y_sampled = sample_both_if_not_none(self._random_generator, X, y_true, n)
    self.features_included = all_if_none(X.columns, features)
    self.pairs = list(combinations(self.features_included, 2))
    self.ovo = _perf_based_ovo(self, model, self.X_sampled, self.y_sampled, n_repeat, show_progress)

    # calculate feature importance
    self._feature_importance_obj = PermutationImportance(self.metric)
    self.feature_importance = self._feature_importance_obj.importance(model, X=self.X_sampled,
                                                                        y_true=self.y_sampled,
                                                                        n_repeat=n_repeat,
                                                                        features=self.features_included,
                                                                        show_progress=show_progress)</code></pre>
</details>
</dd>
<dt id="artemis.interactions_methods.model_agnostic.SejongOhMethod.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, vis_type: str = 'heatmap', title: str = 'default', figsize: Tuple[float, float] = (8, 6), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot results of explanations.</p>
<p>There are four types of plots available:
- heatmap - heatmap of feature interactions values with feature importance values on the diagonal (default)
- bar_chart - bar chart of top feature interactions values
- graph - graph of feature interactions values
- summary - combination of other plots </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vis_type</code></strong> :&ensp;<code>str </code></dt>
<dd>Type of visualization, one of ['heatmap', 'bar_chart', 'graph', 'summary']. Default is 'heatmap'.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str </code></dt>
<dd>Title of plot, default is 'default' which means that title will be automatically generated for selected visualization type.</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>(float, float) </code></dt>
<dd>Size of plot. Default is (8, 6).</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>Other Parameters</code></dt>
<dd>Additional parameters for plot. Passed to suitable matplotlib or seaborn functions.
For 'summary' visualization parameters for respective plots should be in dict with keys corresponding to visualization name.
See key parameters below.</dd>
</dl>
<h2 id="other-parameters">Other Parameters</h2>
<dl>
<dt><strong><code>interaction_color_map</code></strong> :&ensp;<code>matplotlib colormap name</code> or <code>object,</code> or <code>list</code> of <code>colors</code></dt>
<dd>Used for 'heatmap' visualization. The mapping from interaction values to color space. Default is 'Purples' or 'Purpler_r',
depending on whether a greater value means a greater interaction strength or vice versa.</dd>
<dt><strong><code>importance_color_map</code></strong> :&ensp;<code> matplotlib colormap name</code> or <code>object,</code> or <code>list</code> of <code>colors</code></dt>
<dd>Used for 'heatmap' visualization. The mapping from importance values to color space. Default is 'Greens' or 'Greens_r',
depending on whether a greater value means a greater interaction strength or vice versa.</dd>
<dt><strong><code>annot_fmt</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'heatmap' visualization. String formatting code to use when adding annotations with values. Default is '.3f'.</dd>
<dt><strong><code>linewidths</code></strong> :&ensp;<code>float</code></dt>
<dd>Used for 'heatmap' visualization. Width of the lines that will divide each cell in matrix. Default is 0.5.</dd>
<dt><strong><code>linecolor</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'heatmap' visualization. Color of the lines that will divide each cell in matrix. Default is 'white'.</dd>
<dt><strong><code>cbar_shrink</code></strong> :&ensp;<code>float</code></dt>
<dd>Used for 'heatmap' visualization. Fraction by which to multiply the size of the colorbar. Default is 1.</dd>
<dt><strong><code>top_k</code></strong> :&ensp;<code>int </code></dt>
<dd>Used for 'bar_chart' visualization. Maximum number of pairs that will be presented in plot. Default is 10.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str </code></dt>
<dd>Used for 'bar_chart' visualization. Color of bars. Default is 'mediumpurple'.</dd>
<dt><strong><code>n_highest_with_labels</code></strong> :&ensp;<code>int</code></dt>
<dd>Used for 'graph' visualization. Top most important interactions to show as labels on edges.
Default is 5.</dd>
<dt><strong><code>edge_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Color of the edges. Default is 'rebeccapurple.</dd>
<dt><strong><code>node_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Color of nodes. Default is 'green'.</dd>
<dt><strong><code>node_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Used for 'graph' visualization. Size of the nodes (networkX scale).
Default is '1800'.</dd>
<dt><strong><code>font_color</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Font color. Default is '#3B1F2B'.</dd>
<dt><strong><code>font_weight</code></strong> :&ensp;<code>str</code></dt>
<dd>Used for 'graph' visualization. Font weight. Default is 'bold'.</dd>
<dt><strong><code>font_size</code></strong> :&ensp;<code>int</code></dt>
<dd>Used for 'graph' visualization. Font size (networkX scale). Default is 10.</dd>
<dt><strong><code>threshold_relevant_interaction</code></strong> :&ensp;<code>float</code></dt>
<dd>Used for 'graph' visualization. Minimum (or maximum, depends on method) value of interaction to display
corresponding edge on visualization. Default depends on the interaction method.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, vis_type: str = VisualizationType.HEATMAP, title: str = &#34;default&#34;,
         figsize: Tuple[float, float] = (8, 6), **kwargs):
    super().plot(vis_type, title, figsize, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="artemis.interactions_methods" href="../index.html">artemis.interactions_methods</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="artemis.interactions_methods.model_agnostic.partial_dependence_based" href="partial_dependence_based/index.html">artemis.interactions_methods.model_agnostic.partial_dependence_based</a></code></li>
<li><code><a title="artemis.interactions_methods.model_agnostic.performance_based" href="performance_based/index.html">artemis.interactions_methods.model_agnostic.performance_based</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod" href="#artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod">FriedmanHStatisticMethod</a></code></h4>
<ul class="">
<li><code><a title="artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.fit" href="#artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.fit">fit</a></code></li>
<li><code><a title="artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.plot" href="#artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.plot">plot</a></code></li>
<li><code><a title="artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.plot_profile" href="#artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.plot_profile">plot_profile</a></code></li>
<li><code><a title="artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.plot_zenplot" href="#artemis.interactions_methods.model_agnostic.FriedmanHStatisticMethod.plot_zenplot">plot_zenplot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="artemis.interactions_methods.model_agnostic.GreenwellMethod" href="#artemis.interactions_methods.model_agnostic.GreenwellMethod">GreenwellMethod</a></code></h4>
<ul class="">
<li><code><a title="artemis.interactions_methods.model_agnostic.GreenwellMethod.fit" href="#artemis.interactions_methods.model_agnostic.GreenwellMethod.fit">fit</a></code></li>
<li><code><a title="artemis.interactions_methods.model_agnostic.GreenwellMethod.plot" href="#artemis.interactions_methods.model_agnostic.GreenwellMethod.plot">plot</a></code></li>
<li><code><a title="artemis.interactions_methods.model_agnostic.GreenwellMethod.plot_profile" href="#artemis.interactions_methods.model_agnostic.GreenwellMethod.plot_profile">plot_profile</a></code></li>
<li><code><a title="artemis.interactions_methods.model_agnostic.GreenwellMethod.plot_zenplot" href="#artemis.interactions_methods.model_agnostic.GreenwellMethod.plot_zenplot">plot_zenplot</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="artemis.interactions_methods.model_agnostic.SejongOhMethod" href="#artemis.interactions_methods.model_agnostic.SejongOhMethod">SejongOhMethod</a></code></h4>
<ul class="">
<li><code><a title="artemis.interactions_methods.model_agnostic.SejongOhMethod.fit" href="#artemis.interactions_methods.model_agnostic.SejongOhMethod.fit">fit</a></code></li>
<li><code><a title="artemis.interactions_methods.model_agnostic.SejongOhMethod.plot" href="#artemis.interactions_methods.model_agnostic.SejongOhMethod.plot">plot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>